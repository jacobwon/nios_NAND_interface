<!DOCTYPE html>
<html>
<head>
	<title>ONFI NIOS NAND Interface</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style>
	.collapsible {
	  background-color: #777;
	  color: white;
	  cursor: pointer;
	  padding: 2px;
	  width: 100%;
	  border: none;
	  text-align: left;
	  outline: none;
	  font-size: 15px;
	}

	.active, .collapsible:hover {
	  background-color: #555;
	}

	.center {
	  display: block;
	  margin-left: auto;
	  margin-right: auto;
	  width: 50%;
	}

	.content {
	  padding: 0 18px;
	  display: none;
	  overflow: hidden;
	  background-color: #f1f1f1;
	}
	</style>
</head>

<body style="background-color: #f1f1f1;padding: 0 18px;">
	<h1 align="center">Documentation of NAND Interface @ UAH</h1>
	<p align="center">Prawar Poudel</p>
	<!-- MT29F64G08CBABA -->
	<hr>
	<hr>

	<h1>Introduction</h1>
	<hr>
	<button type="button" class="collapsible"> <i>Preliminary</i></button>
		<div class="content">
			<p>
				NAND flash memory is extensively used for mass storage purpose. They have found their usage in SSDs., memory cards and are also used in almost all the gadgets in todays electronic ecosystem. A number of research focused on NAND memory or flash memory in general are performed focusing primarily in using these memory for security purposes, securing data, making efficient storage strategy etc.
			</p>
			<p>
				In this research, we present an interface to the NAND memory, specifically flash memory that is compliant to Open NAND Flash Interface (ONFI 2.3). The flash memory is interfaced to NIOS computer system. The NIOS computer system is implemented in DE1-SoC where the computer runs at 100Mhz frequency. Most of the research work presented for NAND flash memory do not reveal the interface they use or it just seems the interface frequency is a bottleneck in the system. Thus we wanted to create infrastructure for anyone interested such that they can modify the content presented here as their own need.
			</p>
			<p>
				Technical requirments are:
				<ul>
					<li>The memory has to be ONFI confirmant.</li>
					<li>The pinout should be TSOP (or make changes pin configuration).</li>
					<li>Please verify and change the pin configuration in the code based on your hardware setting.</li>
				</ul>
			</p>
			<p>
				Althuogh, this implemtation is based on NIOS computer in DE1-SoC system, you can pretty much use it with any microcontroller changing the value of following variables.
				<ul>
					<li>JUMPER_LOCATION</li>
					<li>JUMPER_DIRECTION</li>
					<li>All the mask values</li>
				</ul>
			</p>
		</div>
	<hr>

	<button type="button" class="collapsible"> <i>What This Document is?</i></button>
	<div>
		<p>
			This document presents a simulatenous discription and observation made from the code that has been written for MT29F64G08CBABA. MT29F64G08CBABA is a flash memory manufactured by Micron Inc. In addition we will make a comparison with the timings expected from the datasheet as well. Although the obesrvations presented are particular to this device, the fundamentals should be same for similar devices.
		</p>
		<p>
			The code implementation can be found at <a href="https://github.com/sickRanchez-c137/nios_NAND_interface">this link</a>.
		</p>
		<p>
			The initial API documentation can be found at <a href="https://sickranchez-c137.github.io/nios_NAND_interface/">this link</a>.
		</p>
		<p>
			Following are some of the interesting details of this particular flash memory.
			<ul>
				<li>It is NAND flash memory.</li>
				<li>It is ONFI 2.3 compliant.</li>
				<li>It is based on MLC technology.</li>
				<li>It has 48-Pin TSOP package.</li>
				<li>The chip is 64 GBits</li>
				<ul>
					<li>It has 4096 blocks.</li>
					<li>It has 2 planes.</li>
					<li>Each plane has 2048 blocks.</li>
					<li>Each block has 256 pages. (2048K+186K bytes)</li>
					<li>Each page is 8192 bytes. (8192 bytes+ 744 bytes)</li>
				</ul>
			</ul>
			Following are some of the information on the set-up that we are using:
			<ul>
				<li>The microcontroller used is NIOS-II computer system implemented on DE1-SoC.</li>
				<li>The processor runs at 100Mhz.</li>
			</ul>
		</p>
	<hr>
	<hr>

		<h1>Instrumenting Flash Operations</h1>
		<hr>
		<p>
			In the following section we will analyze the timing characteristics of the different implemented functions in our firmware. Each of the mesurement is made by adding the <i>timer_start()</i> function and <i>STOP_PRINT_CC_TAKEN</i> macro at the beginning and at the end of the function inside the function. This should give the number of clock cycles taken by the function to execute excluding the time taken to initialize stact and jump execution to the function. Thus, this time is called <i>InTime (Ti)</i>.
		</p>
		<p>
			Just placing these two instrumenting codes consumes 9cc.
			<pre>
				<code>
					timer_start();	//start timer (inline function)
					STOP_PRINT_CC_TAKEN; // macro that captures timer value and prints cc taken
				</code>
				They consume 9cc.
			</pre>
		</p>
		<p>
			Another measurement is made for each of the function where the function call <i>timer_start()</i> is placed before the function call of the function to be measured. After the function returns, the macro <i>STOP_PRINT_CC_TAKEN</i> is placed. This should include the time required to setup stack, jump execution as well as the actual function operation. We call this time <i>OutTime (To)</i>.
		</p>
		<p>
			The instrumentation code <i>timer_start()</i> and <i>STOP_PRINT_CC_TAKEN</i> are removed from the code after their need is finished.
		</p>
		<hr>
		<hr>
		Some Important Observations made are as follows:
		<ul>
			<li>
				Each instruction that updates the state of a pin (interfaced to the NAND chip) on average takes 86 cc (860 ns).
			</li>
			<li>
				Instrumenting code consumes 9cc. Thus all the time measurements presented in clock cycles should be subtracted with 9cc for accurate value.
			</li>
		</ul>
	</div>
	<hr>
	<button type="button" class="collapsible"> <i>Copyright</i></button>
		<div class="content">
		<p>
			Copyright (c) 2020 Prawar Poudel
		</p>
		<p>
			Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
		</p>
		<p>
			The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
		</p>
		<p>
			THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		</p>
	</div>
	<hr>
	<hr>

	<h1>Technical Details</h1>
	<hr>
		<button type="button" class="collapsible">Computer System</button>
		<div class="content">
			<p>
				NIOS computer system is a soft core processor that can be instantiated on Intel FPGA device which can be programmed into the FPGA using Intel Platform Designer program that comes integrated with Quartus. It is a complete computer system and thus a complete description of NIOS system is out of scope for this document. Any interested reader should follow the pdf document as this <a href="ftp://ftp.intel.com/Pub/fpgaup/pub/Intel_Material/17.0/Tutorials/Nios2_introduction.pdf">link</a>.
			</p>
			<p>
				Of the different versions of the architectures of NIOS, we are using the "fast" or <i>NIOS II/f</i> configuration. Since it is softcore, you can choose whatever you want to program into the FPGA fabric.
			</p>
			<p>
				The platform that we are using is DE1-SoC system. The basic NIOS computer system for DE1-SoC system is provided by Intel under University Program. No change in the basic computer system is made as of this point.
			</p>
		</div>
<hr>
		<button type="button" class="collapsible">Interface Detail</button>
		<div class="content">
			<p>
				ONFI standard defines NAND flash memory to be interfaced with parallel data lines. These data lines are 8-bit wide signals that also can be used to transfer command as well as the address.
			</p>
			<p>
				Some of the other signals that are needed for interface are: <i>Address Latch Enable (ALE), Command Latch Enable (CLE), Read Enable (RE), Write Enable (WE), Ready/BUSY (R/B), Chip Enable (CE) and Write Protect (WP)</i>.
			</p>
			<p>
				The packages can be 40-pin TSOP or 100-pin BGA for NAND flash memory. In our case the flash memory is MT29F64G08CBABA from Micron Technology which is a 40-pin TSOP flash memory. It is a MLC NAND flash memory in which each cell of flash memory can store 2-bits information.
			</p>
			<p>
				On the microcontroller side, we are using NIOS computer as our microcontroller in DE1-SoC. The parallel port of the DE1-SoC is used to interface with the flash memory. Each parallel port is 32-bit wide, thus it is sufficient to use a single parallel port for our interfacing purpose. Since all the IO are memory mapped, the address of the data is indicated by <i>JUMPER_LOCATION</i> in the code, while the direction register is indicated by <i>JUMPER_DIRECTION</i>.
			</p>
			<p>
				Other pins that are used for our case are indicated by the <i>mask</i> values in the header file. Please refer to the header file before porting the code for your purpose. You may need to change the code as necessary.
			</p>
		</div>

	<hr>
	<hr>

	<h1>Performance Analysis</h1>
	<hr>
	<button type="button" class="collapsible"> <i>Device Initialization</i></button>
		<div>
			<ul>
				<li>
					Device Initialization function is the first function that is to be called when starting the NAND flash device. This function sets the pin direction appropriately such that only the pin R/B# is set as input for the microcontroller.
				</li>
				<li>
					We must wait for 50 microseconds as indicated in the datasheet. This 50us should be from the start of the supply power application (ie voltage ramp).
				</li>
				<li>
					Following diagram for device initialization is obtained from the device manual.
				</li>
				<img src="images/1_deviceinit.PNG" class="center">
				<li>
					After waiting appropriately, we start probing the RB# signal to see if the NAND flash chip is ready. This will be indicated by a logic 1 at the RB pin which we test using a while loop.
				</li>
				<li>
					After the RB# is high, we will send a reset signal to the device.
				</li>
				<li>
					Measurement OutTime = 51901 cc (519010 ns when called from main function)
				</li>
				<li>
					Measurement InTime = 51866 cc (518660 ns)
				</li>
				<li>
					The <i>for</i> loop in the code designed for delay consumes 50535 cc (505350 ns = 50.5 us).
				</li>
				<li>
					After the delay is finished, the <i>while</i> loop that probes the RB# signal waits for about 73 cc (730 ns)
				</li>
				<li>
					The call to reset device function is made after the <i>while</i> loop. This function call consumes 1132 cc (11320 ns)
				</li>
			</ul>
		</div>
		<hr>
	<button type="button" class="collapsible"> <i>Reset Device</i></button>
		<div>
			<ul>
				<li>
					Reset command puts the device to a known condition and aborts any ongoing operations.
				</li>
				<li>
					Following images shows the Reset operation in action:
				</li>
				<img src="images/2_reset.PNG" class="center">
				<li>
					From above observation, we can see that the OutTime of reset operation is 1132 cc.
				</li>
				<li>
					Measurement InTime = 1014 cc (ie 10140 ns)
				</li>
				<li>
					Here, a call to function <i>send_command(..)</i> takes 921 cc (9210 ns)
				</li>
				<li>
					We should provide a mandatory delay of <b>tWB = 200 ns maximum</b>. Our provided delay is 32 cc that would essentially means 32-9 = 21 cc (210 ns)
				</li>
				<li>
					The while loop here waits for 69cc waiting for the RB# signal.
				</li>
			</ul>
		</div>
		<hr>
	<button type="button" class="collapsible"> <i>Send Command</i></button>
		<div>
			<ul>
				<li>
					Same data lines are used for command and data values. Thus it the function of other signals/pins to indicate the nature of the transfer.
				</li>
				<li>
					Following is the timing diagram of the command cycle according to the manual.
				</li>
				<img src="images/3_sendcommand.PNG" class="center">
				<li>
					The function is implemented as an inline function and it is enforced. So, the InTime should be equal to OutTime measurements. OutTime from above is 921 cc.
				</li>
				<li>
					InTime measurement is observed at 911 cc (9110 ns)
				</li>
				<li>
					In the implemented function, the change in pins are maintained in an order to meet the need specified in the manual.
				</li>
				<li>
					After we load the command on the pins, we wait for 15 cc (ie 15-9 = 6 cc ie 60 ns) to allow sampling (specified time is 40 ns).
				</li>
				<li>
					Once we disable the WE# signal, we allow it to wait for 28cc (ie 28-9 = 19cc ie 190 ns) for holding (specified time is 20 ns).
				</li>
				<li>
					Thus sending each byte of command takes 9.1 us or 9.2 us.
				</li>
				<li>
					Before going out of the function, we disable the CLE signal and reset all the values on the DQ pins (data lines).
				</li>
			</ul>
		</div>
		<hr>
	<button type="button" class="collapsible"> <i>Send Address/es</i></button>
		<div>
			<ul>
				<li>
					Function to send address is also implemented as an inline function.
				</li>
				<li>
					Following is the timing diagram for the address sending sequence:
				</li>
				<img src="images/4_sendaddress.PNG" class="center">
				<li>
					Sending address needs variable number of address bytes to be sent to the NAND device. For block operation, we just need to send 3 bytes while for page operation, we need to send 5 bytes of the address data.
				</li>
				<li>
					We condition the operation  by setting the pins of NAND device as mentioned in the manual. We set CE# and CLE to low, and ALR and RE# to high.
				</li>
				<li>
					The address bytes are loaded in a loop. We set the WE# to high and load the address byte to the pins. After each byte is loaded onto the DQ pins, we wait for same set up time as in Send Command above. We then set WE# to high, and wait for another time equal to hold time (same as in Send Command above). 
				</li>
				<li>
					After all the bytes are sent, we lower ALE pin and clear data off the DQ pins.
				</li>
				<li>
					The InTime measured for sending 5 byte address is 2200 cc (22000 ns ie 22 us). Silimar time measured for sending 3 bytes address is 1660 cc (ie 16620 ns ie 16 us)
				</li>
				<li>
					The OutTime measured for the above measurement made from <i>read_page(..)</i> function is 2278 cc (22780 ns = 22.7 us). Similar the OutTime measured for sending 3 address bytes is 1673 cc (16730 ns = 16.7 us)
				</li>
			</ul>
		</div>
		<hr>
	<button type="button" class="collapsible"> <i>Send Data</i></button>
		<div>
			<ul>
				<li>
					The function <i>send_data()</i> is implemented as an inline function.
				</li>
				<li>
					The task of this function is to copy the user data to the cache function. This data in cache function will be used by the program operation to program to specified location in NAND memory.
				</li>
				<li>
					Since the data to be sent can vary in the number of bytes to be sent. Thus the arguments to the function are: the pointer to the data array and number of items in the array. There is no  return value.
				</li>
				<li>
					Following image shows the timing diagram of the operation:
				</li>
				<img src="images/5_senddata.PNG" class="center">
				<li>
					In the function, we first set up the pins to condition for data input to NAND chip.
				</li>
				<li>
					Then, we use a for loop to send each data byte through the pins to the NAND chip.
				</li>
				<li>
					Making a call to <i>send_data()</i> with 8192 bytes ie while programming a page, the OutTime measured is 2801389 cc (28013890 ns = 28.01 ms). InTime for the same was measured to be 2774644 cc (27746440 ns = 27.75 ms)
				</li>
			</ul>
		</div>
		<hr>
	<button type="button" class="collapsible"> <i>Get Data</i></button>
		<div>
			<ul>
				<li>
					The function <i>get_data()</i> is not implemented as an inline function.
				</li>
				<li>
					In the function, we first change the direction of the pins to condition them to receive data bytes. This function actually acquires the content of the cache and spits them out one byte at a time to the data pins.
				</li>
				<li>
					Following image shows the timing diagram of the operation:
				</li>
				<img src="images/6_getdata.PNG" class="center">
				<li>
					Since the number of bytes to be read depends on the use case and the need of the user, the arguments to the functions are: the pointer to the data array and the number of bytes to read.
				</li>
				<li>
					InTime taken to get 8194 bytes takes 2134689 cc (21346890 ns = 21.35 ms). This is the time it takes by the implemented code to transfer the data from cache to the interfacing microcontroller array.
				</li>
				<li>
					The OutTime for the same operation is measured as 2134799 cc (21347990 ns = 21.34 ms)
				</li>
				<li>
					The same function is also used for checking status from the status register. While erase operation, the <i>get_data()</i> with 1 byte to read costs on average of (OutTime) 1065 cc (10650 ns = 10 us) while for page program operation, the OutTime is 917 cc (9170 ns = 9.17 us).
				</li>
			</ul>
		</div>
		<hr>
	<button type="button" class="collapsible"> <i>Erase Block</i></button>
		<div>
			<ul>
				<li>
					Erase Block operation is implemented as function <i>erase_block()</i>. The function takes an array of bytes as argument. This array should correspond the row address of the block to be erased in the form {R1,R2,R3} where R1 is the lowest address byte.
				</li>
				<li>
					Following image shows the timing diagram of the operation:
				</li>
				<img src="images/7_eraseblock.PNG" class="center">
				<li>
					After the address bytes are sent and the final command byte is sent to the NAND device, we wait for mandatory <i>tWB = 200 ns</i>.
				</li>
				<li>
					InTime Measurement of erase block is measured as 174942 cc (1749420 ns = 1.7 ms). This is the time that includes both the methods of checking status:
					<ul>
						<li>
							wait on RB# signal
						</li>
						<li>
							check status register
						</li>
					</ul>
				</li>
				<li>
					OutTime measurement of erase block is measured as 174515 cc (1745150 ns = 1.74 ms).
				</li>
			</ul>
		</div>
		<hr>
	<button type="button" class="collapsible"> <i>Program Page</i></button>
		<div>
			<ul>
				<li>
					Program page operation is implemented in function named <i></i>
				</li>
				<li>
					In order to program a page, we need to send five byte address of the page to be programmed and 8192 bytes of the data to be programmed to the NAND flash in the sequence as shown in the figure above.
				</li>
				<li>
					Following image shows the timing diagram of the operation:
				</li>
				<img src="images/8_programpage.PNG" class="center">
				<li>
					After the address and data sequence are sent, then we must wait for a mandatory time of <i>tWB = 200 ns</i>.
				</li>
				<li>
					The end of program operation is can be confirmed by checking Ready signal, and the status can be checked by reading the status register.
				</li>
				<li>
					InTime measurement for a page program including the <i>send_data()</i> for 8192 bytes is 2889031 cc (28890310 ns = 28.90 ms). Time time for program operation after the last command sequence, however, is measured as 107834 cc (1078340 ns = 1.08 ms).
				</li>
			</ul>
		</div>


<hr>
<hr>


		<script>
			var coll = document.getElementsByClassName("collapsible");
			var i;

			for (i = 0; i < coll.length; i++) {
			  coll[i].addEventListener("click", function() {
			    this.classList.toggle("active");
			    var content = this.nextElementSibling;
			    if (content.style.display === "block") {
			      content.style.display = "none";
			    } else {
			      content.style.display = "block";
			    }
			  });
			}
		</script>
</body>
</html>
