<!DOCTYPE html>
<html>
<head>
	<title>NIOS NAND Interface: Documentation</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style>
	.collapsible {
	  background-color: #777;
	  color: white;
	  cursor: pointer;
	  padding: 18px;
	  width: 100%;
	  border: none;
	  text-align: left;
	  outline: none;
	  font-size: 15px;
	}

	.active, .collapsible:hover {
	  background-color: #555;
	}

	.content {
	  padding: 0 18px;
	  display: none;
	  overflow: hidden;
	  background-color: #f1f1f1;
	}
	</style>
</head>

<body style="background-color: #f1f1f1;padding: 0 18px;">
	<h1 align="center">ONFI 2.2 NAND Flash Interface with NIOS Computer</h1>
	<p align="center">Prawar Poudel</p>

	<h1>Introduction</h1>
	<button type="button" class="collapsible"> <i>Preliminary</i></button>
		<div class="content">
			<p>
				NAND flash memory is extensively used for mass storage purpose. They have found their usage in SSDs., memory cards and are also used in almost all the gadgets in todays electronic ecosystem. A number of research focused on NAND memory or flash memory in general are performed focusing primarily in using these memory for security purposes, securing data, making efficient storage strategy etc.
			</p>
			<p>
				In this research, we present an interface to the NAND memory, specifically flash memory that is compliant to Open NAND Flash Interface (ONFI 2.2). The flash memory is interfaced to NIOS computer system. The NIOS computer system is implemented in DE1-SoC where the computer runs at 100Mhz frequency. Most of the research work presented for NAND flash memory do not reveal the interface they use or it just seems the interface frequency is a bottleneck in the system. Thus we wanted to create infrastructure for anyone interested such that they can modify the content presented here as their own need.
			</p>
			<p>
				Technical requirments are:
				<ul>
					<li>The memory has to be ONFI confirmant.</li>
					<li>The pinout should be TSOP (or make changes pin configuration).</li>
					<li>Please verify and change the pin configuration in the code based on your hardware setting.</li>
				</ul>
			</p>
			<p>
				Althuogh, this implemtation is based on NIOS computer in DE1-SoC system, you can pretty much use it with any microcontroller changing the value of following variables.
				<ul>
					<li>JUMPER_LOCATION</li>
					<li>JUMPER_DIRECTION</li>
					<li>All the mask values</li>
				</ul>
			</p>
		</div>

	<button type="button" class="collapsible"> <i>Copyright</i></button>
		<div class="content">
		<p>
			Copyright (c) 2020 Prawar Poudel
		</p>
		<p>
			Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
		</p>
		<p>
			The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
		</p>
		<p>
			THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		</p>
	</div>

	<h1>Technical Details</h1>
		<button type="button" class="collapsible">Computer System</button>
		<div class="content">
			<p>
				NIOS computer system is a soft core processor that can be instantiated on Intel FPGA device which can be programmed into the FPGA using Intel Platform Designer program that comes integrated with Quartus. It is a complete computer system and thus a complete description of NIOS system is out of scope for this document. Any interested reader should follow the pdf document as this <a href="ftp://ftp.intel.com/Pub/fpgaup/pub/Intel_Material/17.0/Tutorials/Nios2_introduction.pdf">link</a>.
			</p>
			<p>
				Of the different versions of the architectures of NIOS, we are using the "fast" or <i>NIOS II/f</i> configuration. Since it is softcore, you can choose whatever you want to program into the FPGA fabric.
			</p>
			<p>
				The platform that we are using is DE1-SoC system. The basic NIOS computer system for DE1-SoC system is provided by Intel under University Program. No change in the basic computer system is made as of this point.
			</p>
		</div>
		<button type="button" class="collapsible">Interface Detail</button>
		<div class="content">
			<p>
				ONFI standard defines NAND flash memory to be interfaced with parallel data lines. These data lines are 8-bit wide signals that also can be used to transfer command as well as the address.
			</p>
			<p>
				Some of the other signals that are needed for interface are: <i>Address Latch Enable (ALE), Command Latch Enable (CLE), Read Enable (RE), Write Enable (WE), Ready/BUSY (R/B), Chip Enable (CE) and Write Protect (WP)</i>.
			</p>
			<p>
				The packages can be 40-pin TSOP or 100-pin BGA for NAND flash memory. In our case the flash memory is MT29F64G08CBABA from Micron Technology which is a 40-pin TSOP flash memory. It is a MLC NAND flash memory in which each cell of flash memory can store 2-bits information.
			</p>
			<p>
				On the microcontroller side, we are using NIOS computer as our microcontroller in DE1-SoC. The parallel port of the DE1-SoC is used to interface with the flash memory. Each parallel port is 32-bit wide, thus it is sufficient to use a single parallel port for our interfacing purpose. Since all the IO are memory mapped, the address of the data is indicated by <i>JUMPER_LOCATION</i> in the code, while the direction register is indicated by <i>JUMPER_DIRECTION</i>.
			</p>
			<p>
				Other pins that are used for our case are indicated by the <i>mask</i> values in the header file. Please refer to the header file before porting the code for your purpose. You may need to change the code as necessary.
			</p>
		</div>
		<button type="button" class="collapsible">Time Measurement Code</button>
		<div class="content">
			<p>
				The interval timer in NIOS computer is used for profiling time. Any user can make use of the preprocessor directives as defined below to make their own profiling. In NIOS, the interval timer can be found at address 0xff202004 and other required registers are subsequently placed.
			</p>
		<pre>
			<code>
				
				// following are the registers in NIOS computer
				// .. the base address
				#define TIMER_BASE ((uint32_t*) 0xff202000)
				// .. the control register
				#define TIMER_CONTROL ((uint32_t*) 0xff202004)
				// .. timer counter low (only 16-bits)
				#define TIMER_COUNTER_LOW ((uint32_t*) 0xff202008)
				// .. timer counter high (only 16-bits)
				#define TIMER_COUNTER_HIGH ((uint32_t*) 0xff20200C)
				// .. timer counter snapshot low (only 16-bits)
				#define TIMER_COUNTER_SNAP_LOW ((uint32_t*) 0xff202010)
				// .. timer counter snapshot high (only 16-bits)
				#define TIMER_COUNTER_SNAP_HIGH ((uint32_t*) 0xff202014)
				// .. instead of making call to timer_diff(), use the following statement
				#define PRINT_CC_TAKEN printf(".. the last operation took %lu cc\n.",timer_diff())

				// function timer_start()
				// .. following function starts the timer in downwards direction
				// .. that means we will have max values in the counter and count downwards
				FORCE_INLINE inline void timer_start()
				{
					*TIMER_COUNTER_LOW = 0xffff;
					*TIMER_COUNTER_HIGH = 0xffff;
					// .. bit 0: interupt enable, bit 1: continuous mode, bit 2:start counting
					*TIMER_CONTROL = 0x006; //0b0110
				}

				// function timer_end()
				// .. following function takes the snapshot from the counter and puts them in snap register
				// .. do not make a call to this function from user code, see timer_diff instead
				FORCE_INLINE inline void timer_end()
				{
					// grab the snap shot value
					// .. to catch the snapshot value, just write anything to the snap register
					*TIMER_COUNTER_SNAP_LOW = 1;
					// now we can stop the timer
					// .. bit 3 is STOP
					*TIMER_CONTROL = 0x08;
				}

				// function timer_diff
				// .. this function gives out the time in nanoseconds as measured by the timer
				FORCE_INLINE inline  uint32_t timer_diff()
				{
					// first stop the timer
					timer_end();
					// the initial value that we started was 0xff ff ff ff ff
					uint32_t clock_count = 0xffffffff-((*TIMER_COUNTER_SNAP_HIGH)*65536+(*TIMER_COUNTER_SNAP_LOW)); // in cc
					return clock_count;
				}
			</code>
		</pre>
		<p>
			An example of the code snippet that measures the time taken by erase operation is shown below:
		</p>
		<pre>
			<code>				
				#if TIMER_PROFILE
					printf("Erase Block Operation Follows\n");
					timer_start();
				#endif
					erase_block(my_page_address+2);
				#if TIMER_PROFILE
					PRINT_CC_TAKEN;
				#endif	
			</code>
		</pre>
		</div>

	<h1>Time Profile of Operations</h1>
		<button type="button" class="collapsible"> Erase Profile </button>
			<div class="content">
				<p>Based on the measurement, the erase operation of two blocks of flash memory each took:</p>
				<ul>
					<li>167701 cc (i.e. 1677010 ns)</li>
					<li>167437 cc (i.e. 1674370 ns)</li>
				</ul>
				<p>Based on this measurement, the erase time of a block is 1.67 ms (~3 ms in Datasheet).</p>
			</div>
		<button type="button" class="collapsible"> Program Profile </button>
			<div class="content">
				<p>Based on the measurement, the program operation of two pages of flash memory each took:</p>
				<ul>
					<li>105181 cc (i.e. 1051810 ns)</li>
					<li>101285 cc (i.e. 1012850 ns)</li>
				</ul>
				<p>Based on this measurement, the program time of a page is 1.0 ms (~1.3 ms in Datasheet).</p>
			</div>
		<button type="button" class="collapsible"> Page Read Profile </button>
			<div class="content">
				<p>Based on the measurement, the page read operation of many rows of flash memory each took:</p>
				<ul>
					<li>45753 cc (i.e. 45753 ns)</li>
					<li>46073 cc (i.e. 46073 ns)</li>
					<li>46153 cc (i.e. 46153 ns)</li>
					<li>47177 cc (i.e. 47177 ns)</li>
					<li>45218 cc (i.e. 45218 ns)</li>
					<li>45560 cc (i.e. 45560 ns)</li>
				</ul>
				<p>Based on this measurement, the program time of a row is 46 us (~100 us in Datasheet).</p>
			</div>
			
	<h1>Code API</h1>
		<p>
			In the following section we will present the description of different functions that are implemented. All these functions are derived from the datasheet of the Micron NAND flash device MT29F64G08CBABA. It should be compliant of ONFI 2.2 standard.
		</p>

		<button type="button" class="collapsible"> <i>Macro Definitions</i></button>
		<div class="content">
		<pre>
			<code>
				// The computer system used here is DE1_SoC that runs at 100Mhz (10 ns period)
				//  connection to the NAND is made in parallel port 1 on JP1
				// .. the address of which is at 0xff200060
				// .. so here we will create masks for the data to be read/written
				#define JUMPER_LOCATION ((uint32_t*) 0xff200060)

				// value 1 in direction register means output
				// .. 0 means input
				// .. following is just the address of the register
				#define JUMPER_DIRECTION ((uint32_t*) 0xff200064)

				#define PUSH_KEY_LOCATION ((uint32_t*) 0xff200050)

				#define DQ_mask (0x000000ff)	//connected at D7D6..D0

				#define WP_shift 8
				#define WP_mask (0x1&lt&ltWP_shift)	// connected at D8

				#define CLE_shift 11
				#define CLE_mask (0x1&lt&ltCLE_shift) // connected at D11

				#define ALE_shift 10
				#define ALE_mask (0x1&lt&ltALE_shift) //connected at D10

				#define RE_shift 13
				#define RE_mask (0x1&lt&ltRE_shift) // connected at D13

				#define WE_shift 9
				#define WE_mask (0x1&lt&ltWE_shift) // connected at D9

				#define CE_shift 12
				#define CE_mask (0x1&lt&ltCE_shift) // connected at D12

				#define RB_shift 14
				#define RB_mask (0x1&lt&ltRB_shift) // connected to D14


				#define SAMPLE_TIME asm("nop");asm("nop");asm("nop")
				#define HOLD_TIME asm("nop");asm("nop");asm("nop");asm("nop");asm("nop")
				// 100ns
				#define tWW asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");asm("nop");asm("nop")
				#define tWB {for(uint8_t i=0;i<20;i++) asm("nop");}
				#define tRR {for(uint8_t i=0;i<4;i++) asm("nop");}
				#define tRHW tWB
				#define tCCS tWB
				#define tADL tWB
				#define tWHR {for(uint8_t i=0;i<12;i++) asm("nop");} // .. tWHR = 120ns
			</code>
		</pre>
		</div>

		<button type="button" class="collapsible"> <i>void send_command(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function to send an arbitrary command signal to the NAND device
				// .. the procedure is as follows ( in the sequence )
				void send_command(uint8_t command_to_send)
				{
					// set the required pins as output from the angle of NIOS machine
					*jumper_direction |= 0x03fff;
					*jumper_direction &= ~0x4000;

					// let us first reset the DQ pints
					*jumper_address &= ~(DQ_mask);

					// .. Write Enable should go low WE => low
					// .. reset the bit that is connected to WE
					*jumper_address &= ~(WE_mask);
					// .. .. Chip Enable should go low CE => low
					*jumper_address &= ~(CE_mask);
					// .. .. ALE should go low ALE => low
					*jumper_address &= ~(ALE_mask);
					// .. RE goes high
					*jumper_address |= RE_mask;
					// .. .. CLE should go high CLE => high
					*jumper_address |= (CLE_mask);

					// .. .. send the command signal in the DQ pins	
					// .. .. the idea is clear the least 8-bits
					// .. .. copy the values to be sent
					*jumper_address = (*jumper_address&(~DQ_mask))|(command_to_send & DQ_mask);

					//insert delay here
					// .. tDS = 40 ns
					SAMPLE_TIME;

					// disable write enable again
					*jumper_address |= (WE_mask);

					//insert delay here
					// .. because the command is written on the rising edge of WE
					// tDH = 20 ns
					HOLD_TIME;

					// disable CLE
					*jumper_address &= ~(CLE_mask);
					
					
					// reset all the data on DQ pins
					*jumper_address &= ~(DQ_mask);
				}
				</code>
			</pre>
		</div>

		<button type="button" class="collapsible"> <i>void send_addresses(..)</i></button>
		<div class="content">
			<pre>
				<code>
			// function to send address to the NAND device 
			// .. the procedure is as follows (in the sequence)
			void send_addresses(uint8_t* address_to_send, uint8_t num_address_bytes)
			{
				// set the required pins as output
				*jumper_direction |= 0x03fff;
				*jumper_direction &= ~0x4000;

			#if DEBUG
				printf("Sending Address: ");
			#endif

			// .. .. CE goes low
			*jumper_address &= ~CE_mask;
			// .. CLE goes low
			*jumper_address &= ~CLE_mask;
			// .. ALE goes high
			*jumper_address |= ALE_mask;
			// .. RE goes high
			*jumper_address |= RE_mask;

			for(uint8_t i=0;i&ltnum_address_bytes;i++)
			{
				*jumper_address &= ~(WE_mask);

			// .. Put data on the DQ pin
			// .. .. the idea is clear the least 8-bits
			// .. .. copy the values to be sent
			*jumper_address = (*jumper_address&(~DQ_mask))|(address_to_send[i] & DQ_mask);
	#if DEBUG
			printf("0x%x,", (uint8_t)*jumper_address&0xff);
	#endif
			//.. a simple delay
			SAMPLE_TIME; //tDS

			// .. Address is loaded from DQ on rising edge of WE
			*jumper_address |= WE_mask;
			// .. maintain WE high for certain duration and make it low
			
			// .. put next address bits on DQ and cause rising edge of WE
			// .. address expected is 5-bytes ColAdd1, ColAdd2, RowAdd1, RowAdd2, RowAdd3
			
			//insert delay here
			HOLD_TIME;	// tDH
			}
			// .. ALE goes low
			*jumper_address &=  ~(ALE_mask);
			// reset all the data on DQ pins
			*jumper_address &= ~(DQ_mask);

			#if DEBUG
				printf("\n");
			#endif
			}
				</code>
			</pre>
		</div>

		<button type="button" class="collapsible"> <i>void send_data(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function to send address from the host machine to the NAND flash
				// .. Data is written from DQ[7:0] to the cache register of the selected die (LUN)
				// .. .. on the rising edge of WE# when CE# is LOW, ALE is LOW, CLE is LOW, and RE# is HIGH
				void send_data(uint8_t* data_to_send,uint16_t num_data)
				{
					// .. CE should be low
					*jumper_address &= ~CE_mask;
					// .. CLE should be low
					*jumper_address &= ~CLE_mask;
					// .. ALE should be low
					*jumper_address &= ~ALE_mask;
					// .. RE should be high
					*jumper_address |= RE_mask;

					for(uint16_t i=0;i&ltnum_data;i++)
					{
						// .. make WE low and repeat the procedure again for number of bytes required (int num_data)
						*jumper_address &= ~WE_mask;

						// .. put data on DQ and latch WE high for certain duration
						// .. .. the idea is clear the least 8-bits
						// .. .. copy the values to be sent
						*jumper_address = (*jumper_address&(~DQ_mask))|(data_to_send[i] & DQ_mask);
						//.. a simple delay
						SAMPLE_TIME;	// tDS

						*jumper_address |= WE_mask;

						//insert delay here
						HOLD_TIME;	//tDH

						// reset all the data on DQ pins
						// .. this might be unnecesary
						*jumper_address &= ~(DQ_mask);		
					}
				}
				</code>
			</pre>
		</div>

		<button type="button" class="collapsible"> <i>void get_data(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function to receive data from the NAND device
				// .. data is output from the cache regsiter of selected die
				// .. it is supported following a read operation of NAND array
				void get_data(uint8_t* data_received,uint16_t num_data)
				{
					// set the DQ pins as IP to the NIOS processor
					// .. 0 is IP and 1 is OP
					*jumper_direction &= ~0x40ff;

					// .. data can be received when on ready state (RDY signal)
					// .. ensure RDY is high
					// .. .. just keep spinning here checking for ready signal
					while((*jumper_address & RB_mask)== 0x00);

					// .. data can be received following READ operation
					// .. the procedure should be as follows
					// .. .. CE should be low
					*jumper_address &= ~CE_mask;
					// .. make WE high
					*jumper_address |= WE_mask;
					// .. .. ALE and CLE should be low
					*jumper_address &= ~ALE_mask;
					*jumper_address &= ~CLE_mask;

					for(uint16_t i=0;i&ltnum_data;i++)
					{			
						// set the RE to high for next cycle
						*jumper_address &= ~RE_mask;

						// tRP = 50ns
						SAMPLE_TIME;
						asm("nop");

						// .. data is available at DQ pins on the falling edge of RE pin (RE is also input to NAND)
						*jumper_address |= RE_mask;
						
						//insert delay here
						// .. tREH = 30 ns
						asm("nop");

						// read the data
						data_received[i] = *jumper_address & DQ_mask;
						asm("nop");
					}

					// set the pins as output
					*jumper_direction |= 0x03fff;	
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void write_protect(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function to disable Program and Erase operation
				// .. when WP is low, program and erase operation are disabled
				// .. when WP is high, program and erase operation are enabled
				void write_protect()
				{
					// check to see if the device is busy
					// .. wait if busy
					while((*jumper_address&RB_mask)==0x00);

					// wp to low
					*jumper_address &= ~WP_mask;	
					
					//insert delay here
					for(uint8_t i=0;i<4;i++);
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void write_enable(..)</i></button>
		<div class="content">
			<pre>
				<code>
				void write_enable()
				{
					// check to see if the device is busy
					// .. wait if busy
					while((*jumper_address&RB_mask)==0x00);

					// wp to high
					*jumper_address |= WP_mask;
					
					//insert delay here
					tWW;
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void device_initialization(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function to initialize the NAND device
				// .. following are the tasks to be performed for initialization of NAND device
				// .. provide Vcc (ie ramp Vcc)
				// .. host must wait for R/B to be valid (R/B should be low for certain duration and be high
				// .. .. to indicate device is ready) R/B is output from the NAND device
				// .. issue 0xFF command after R/B goes high (Reset is the first command to be issued)
				// .. R/B should be monotired again after issuing 0XFF command
				void device_initialization()
				{
					*jumper_direction &= ~0x4000;
					*jumper_direction |= 0x3fff;

					//insert delay here
					for(uint16_t i=0;i<5000;i++);	//50 us max

					// wait for R/B signal to go high
					while((*jumper_address & RB_mask)==0);
					// now issue RESET command
					reset_device();
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void reset_device(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function to reset the whole device
				// .. issue a command 0xFF for reset operation
				// .. following operations should be performed for this
				// .. .. enable command cycle
				// .. .. command to be sent is 0xFF
				// .. .. check for R/B signal to be high after certain duration (should go low(busy) and go high (ready))
				void reset_device()
				{
					// oxff is reset command
					send_command(0xff);
					// no address is expected for reset command
					// wait for busy signal again
					
					//insert delay here
					// .. not needed because the next polling statement will take care
					// .. polling the Ready/BUSY signal
					// .. but we should wait for tWB = 200ns before the RB signal is valid
					tWB;	// tWB = 200ns

					while((*jumper_address & RB_mask)==0);
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void reset_LUN(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// following function will reset just a particular LUN
				// .. a LUN or logical unit is also called a NAND flash die (our NAND has 2 planes in a die)
				// .. can be used to put the LUN into a known state or abort commadn sequences going on
				// .. .. all the cache contents are invalid
				// .. .. if any operation is going on, partial operations might take place
				// .. .. the command issuing has to be followed by sequence of (3-byte) address of the LUN
				void reset_LUN(uint8_t* address_LUN, uint8_t num_address_bytes)
				{
					// 0xfa is the reset LUN command
					send_command(0xfa);
					// send the address of the LUN to reset
					send_addresses(address_LUN,num_address_bytes);
					
					//insert delay here
					tWB;//tWB
					while((*jumper_address & RB_mask)==0);	
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void read_device_id_00(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function to read the device ID
				// when read from address 00h, it returns 8-byte ID of which first 5-bytes are manufacturer ID
				// follow the following sequences
				// .. set command cycle
				// .. .. send 90h as command
				// .. set address sending mode
				// .. ..send 00 as address
				// .. wait for tWHR duration
				// .. read 8-bytes from the DQ pins
				void read_device_id_00(uint8_t* device_id_array)
				{
					// make sure none of the LUNs are busy
					while((*jumper_address & RB_mask)==0);
					// read ID command
					send_command(0x90);
					// send address 00
					send_address(0x00);
					// wait for tWHR duration
					
					//insert delay here
					// .. tWHR = 120ns
					tWHR;

					get_data(device_id_array,8);
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void detect_device(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function that reads the device ID and tries to detect the device name
				// .. call the function device_id at address 00h
				// .. lookup table based finding for device name
				// .. this function is not decisive
				void detect_device()
				{
					// create a 8-byte variable
					// .. static array
					uint8_t my_device_id[8];

					// following call should return the device ID to the array
					read_device_id_00(my_device_id);
					char device_name[20] = "?";
					// now check each bytes
					if(my_device_id[0]==0x2c)
					{
						if(my_device_id[1]==0x88)
						{
							if(my_device_id[2]==0x04)
							{
								if(my_device_id[3]==0x4b)
								{					
									if(my_device_id[4]==0xa9)
									{
										strcpy(device_name,"MT29FxxxG08Cxxxx\0");	
									}
								}
							}
						}else if(my_device_id[1]==0xA8)
						{
							if(my_device_id[2]==0x05)
							{
								if(my_device_id[3]==0x5b)
								{
									if(my_device_id[4]==0xa9)
									{
										strcpy(device_name,"MT29FxxxG08Cxxxx\0");	
									}					
								}				
							}
						}else if(my_device_id[1]==0x64)
						{
							if(my_device_id[2]==0x44)
							{
								if(my_device_id[3]==0x4b)
								{
									if(my_device_id[4]==0xa9)
									{
										strcpy(device_name,"MT29F64G08CBABA\0");	
									}					
								}				
							}
						}
					}

					if(device_name[0]=='?')
					{
						printf("Device Family Not Recognized\n");
					}else
					{
						printf("Detected Device ID is %s\n", device_name);
					}
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void read_device_id_20(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function to read the 4-byte ONFI code
				// when read from address 00h, it returns 4-byte ONFI code
				// follow the following sequences
				// .. set command cycle
				// .. .. send 90h as command
				// .. set address sending mode
				// .. ..send 20 as address
				// .. wait for tWHR duration
				// .. read 4-bytes from the DQ pins
				void read_device_id_20(uint8_t* device_id_array)
				{
					// make sure none of the LUNs are busy
					while((*jumper_address & RB_mask)==0);
					// read ID command
					send_command(0x90);
					// send address 00
					send_address(0x20);
					// wait for tWHR duration
					
					// .. tWHR = 120ns
					tWHR;

					get_data(device_id_array,4);
				#if DEBUG
					printf("After reading from the device\n");
					print_array(device_id_array,4);
				#endif
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void read_unique_id(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function to read the unique identifier programmed into the target
				// .. only accepted when device is not busy
				// .. start a command cycle with 0x70 as command
				// .. start a address cycle of 0x00 as address
				// .. target is busy for tR , can be tested using R/B# signal begin high to indicate if the device is ready
				// .. one data byte is output per RE# toggle at DQ pin
				// .. .. 32 bytes of data is received
				// .. .. .. first 16 bytes is the unique ID and next 16-bytes is complement of the data
				// .. .. .. XOR should be done to ensure correctness
				void read_unique_id(uint8_t* device_id_array, uint8_t num_data)
				{
					// make sure none of the LUNs are busy
					while((*jumper_address & RB_mask)==0);

					// command for read unique ID
					send_command(0xed);	
					// address, lets send 00
					send_address(0x00);

					
					//insert delay here
					// ..tWB = 200ns
					tWB;

					// make sure none of the LUNs are busy
					while((*jumper_address & RB_mask)==0);

					// read from different address
					// change_read_column();

					uint8_t* data_temp = (uint8_t*)malloc(32*sizeof(uint8_t));

					tRR;

				#if DEBUG
					printf("Before reading from the device\n");
					print_array(data_temp,32);
				#endif

					get_data(data_temp,32);


				#if DEBUG
					printf("After reading from the device\n");
					print_array(data_temp,32);
				#endif

					// now check the validity of the data
					for(uint8_t i=0;i<16;i++)
					{
						if((data_temp[i]^data_temp[16+i]) != 0xff)
						{
							printf("Error in reading the unique device ID\n");
							break;
						}
					}
					for(uint8_t i=0;i&ltnum_data;i++)
					{
						device_id_array[i] = data_temp[i];
					}
					free(data_temp);
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void read_status(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// following function can be used to read the status following any command
				void read_status(uint8_t* status_value)
				{
					send_command(0x70);	
					//insert delay here
					// .. tWHR= 120ns
					tWHR;

					get_data(status_value,1);
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void read_status_enhanced(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// use this for multi-LUN device to avoid bus contention
				// .. r1, r2 and r3 are the three-bytes for the row addresss
				void read_status_enhanced(uint8_t* status_value, uint8_t* r1r2r3)
				{
					send_command(0x78);
					send_addresses(r1r2r3,3);
					
					//insert delay here
					//insert delay here
					// .. tWHR= 120ns
					tWHR;

					get_data(status_value,1);	
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void print_array(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// just a normal function to print an array to terminal
				void print_array(uint8_t* my_array, uint16_t len)
				{
					for(uint16_t i=0;i&ltlen;i++)
					{
						printf("0x%x ", my_array[i]);
					}
					printf("\n");
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void change_read_column(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// follow the following function call by get_data() function call
				// .. please change this if the device has multiple dies
				void change_read_column(uint8_t* col_address)
				{
					tRHW;	// tRHW = 200ns

					send_command(0x05);
					send_addresses(col_address,2);

					send_command(0xe0);

					tCCS;	//tCCS = 200ns
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void change_read_column_enhanced(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// follow the following function call by get_data() function call
				void change_read_column_enhanced(uint8_t* address)
				{
					tRHW;	// tRHW = 200ns

					send_command(0x06);
					send_addresses(address,5);

					send_command(0xe0);

					tCCS;	//tCCS = 200ns
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void change_write_column(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// following function call should be followed by send_data() function calls
				// .. this just changes the address in the selected cache register
				void change_write_column(uint8_t* col_address)
				{
					send_command(0x85);
					send_addresses(col_address,2);

					tCCS;	//tCCS = 200ns
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void change_row_address(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// change teh row address where the cache register contents will be programmed in NAND flash
				// .. row address means block and page address
				// .. data input is optional after the address cycles
				// .. .. data input begins at the column address specified
				void change_row_address(uint8_t* address)
				{
					send_command(0x85);

					send_addresses(address,5);

					// .. wait before inputting the data
					tCCS;	//tCCS = 200ns
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void read_page(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// write a function to perform an read operation from NAND flash to cache register
				// .. reads one page from the NAND to the cache register
				// .. during the read, you can use change_read_column and change_row_address
				void read_page(uint8_t* address,uint8_t address_length)
				{
					// make sure none of the LUNs are busy
					while((*jumper_address & RB_mask)==0);

					send_command(0x00);
					send_addresses(address,address_length);
					send_command(0x30);

					// just a delay
					tWB;
					// check for RDY signal
					while((*jumper_address & RB_mask)==0);
					// tRR = 40ns
					tRR;
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void read_page_cache_sequential(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// following is the faster read operation
				// .. essentially calls the read_page function above
				// .. and reads the output data from the cache and at the same time copies next page to the data regsiter
				void read_page_cache_sequential(uint8_t* address, uint8_t address_length,uint8_t* data_read,uint16_t* data_read_len,uint16_t num_pages)
				{
					// make sure none of the LUNs are busy
					while((*jumper_address & RB_mask)==0);

					send_command(0x00);
					send_addresses(address,address_length);
					send_command(0x30);

					// just a delay
					tWB;

					// check if it is out of Busy cycle
					while((*jumper_address & RB_mask)==0);
					// lets wait again
					tRR;

					for(uint16_t page_num = 0;page_num&ltnum_pages-1;page_num++)
					{
						send_command(0x31);
						// just a delay
						tWB;

						// check if it is out of Busy cycle
						while((*jumper_address & RB_mask)==0);
						// lets wait again
						tRR;

						*data_read_len = 8192;
						get_data(data_read+(page_num*(*data_read_len)),*data_read_len);
					}	

					// read page cache last
					send_command(0x3f);
					// just a delay
					tWB;

					// check if it is out of Busy cycle
					while((*jumper_address & RB_mask)==0);
					// lets wait again
					tRR;

					*data_read_len = 8192;
					get_data(data_read+((num_pages-1)*(*data_read_len)),*data_read_len);
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void read_mode(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// enables data output for the last selected die and cache register
				// .. after a READ operation has been monitored
				void read_mode()
				{
					send_command(0x00);
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void program_page(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// program operation is used to move data from cache or data regsiter to NAND array
				// .. during program operation, the contents of cache or data registers are modified by internal control logic
				// .. pages in a block should be programmed from the least significant page to the most sign addres
				// .. programming pages out of order in a block is not allowed
				// .. address: should be 5 bytes and data should be 
				void program_page(uint8_t* address,uint8_t* data,uint16_t num_data)
				{
					// 
					send_command(0x80);
					send_addresses(address,5);

					// tADL
					tADL;

					send_data(data,num_data);
					send_command(0x10);

					tWB;
					
				#if DEBUG
					printf("Inside program Fn: Address is: ");
					print_array(address,5);
				#endif
					// check if it is out of Busy cycle
					while((*jumper_address & RB_mask)==0);

					uint8_t status_value;
					// .. use  the commended code for multi-plane die
					// read_status_enhanced(&status_value,(address+2));
					read_status(&status_value);
					if(status_value&0x01)
					{
						printf("Failed Program Operation\n");
					}else
					{
				#if DEBUG
				printf("Program Operation Successful\n");
				#endif
					}
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void program_page_cache(..)</i></button>
		<div class="content">
			<pre>
				<code>
				// function used to program multiple pages
				// the data is copied to the cache, and then to the NAND memory
				// .. there is no need to wait for the previous operation to complete
				// .. and can move on with next program operation of page
				// address is an array with multiple of 5, each representing the address of each page
				// data is same programmed to each page
				// num_data is the number of bytes of data in data array
				void program_page_cache(uint8_t* address,uint8_t* data,uint16_t num_data,uint8_t num_pages)
				{
					for(uint8_t page_num = 0;page_num&ltnum_pages-1;page_num++)	
					{
						send_command(0x80);
						send_addresses(address+(5*page_num),5);

						// tADL
						tADL;

						send_data(data,num_data);
						send_command(0x15);

						tWB;

						// check if it is out of Busy cycle
						while((*jumper_address & RB_mask)==0);
					}
					send_command(0x80);
					send_addresses((address+5*(num_pages-1)),5);

					// tADL
					tADL;

					send_data(data,num_data);
					send_command(0x10);

					tWB;

					// check if it is out of Busy cycle
					while((*jumper_address & RB_mask)==0);

					uint8_t status_value;
					// .. use  the commended code for multi-plane die
					// read_status_enhanced(&status_value,(address+2));
					read_status(&status_value);
					if(status_value&0x01)
					{
						printf("Failed Program Operation\n");
					}else
					{
				#if DEBUG
				printf("Program Operation Successful\n");
				#endif
					}
				}
				</code>
			</pre>
		</div>


		<button type="button" class="collapsible"> <i>void erase_block(..)</i></button>
		<div class="content">
			<pre>
				<code>
				void erase_block(uint8_t* row_address)
				{	
					*jumper_direction &= ~RB_mask;

					// check if it is out of Busy cycle
					while((*jumper_address & RB_mask)==0);

					send_command(0x60);
					send_addresses(row_address,3);
					send_command(0xd0);

					tWB;
					
				#if DEBUG
					printf("Inside Erase Fn: Address is: ");
					print_array(row_address,3);
				#endif

					// check if it is out of Busy cycle
					while((*jumper_address & RB_mask)==0);

					// let us read the status register value
					uint8_t status;
					read_status(&status);	
					if(status&0x01)
					{
						printf("Failed Erase Operation\n");
					}else
					{
				#if DEBUG
				printf("Erase Operation Successful\n");
				#endif
					}
				}
				</code>
			</pre>
		</div>

		<script>
			var coll = document.getElementsByClassName("collapsible");
			var i;

			for (i = 0; i < coll.length; i++) {
			  coll[i].addEventListener("click", function() {
			    this.classList.toggle("active");
			    var content = this.nextElementSibling;
			    if (content.style.display === "block") {
			      content.style.display = "none";
			    } else {
			      content.style.display = "block";
			    }
			  });
			}
		</script>
</body>
</html>